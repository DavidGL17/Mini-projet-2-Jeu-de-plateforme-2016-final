Voici le fichier conception de notre mini-projet. Nous l’avons structurés comme ceci : Nous allons nous arrêter sur chaque package pour expliquer pourquoi nous avons créé ce package (sauf pour platform.game, celui la étant déjà existant) ainsi qu’en expliquant les détails d’implémentation des classes comme demandés dans les consignes. Les interfaces et énumérations sont indiquées.


- Package platform.game :
Actor :Nous avons décidé de mettre la box et Sprite dans Actor, car c'est des attribut que tous les acteurs partagent. Idem pour World et priority. Nous avons pas changé les méthodes fournies pour cette classe. Nous avons uniquement rajouté certains setters et getters, notamment pour sprite et box. setSprite est public car, à cause de notre packaging, nous ne pouvons la mettre en protected. Les méthodes isPlayer et isLimiteTangible permettent d’éviter les instanceOf et facilitent le code.
Simulator : De nouveau nous n’avons pas beaucoup changé les méthodes importantes du code qui ont été proposées. Nos seuls changement sont par rapport à nos changement de niveaux. Dans notre envie de créer un jeu composé d’un mode histoire et d’un mode où l’on peut choisir son niveau, nous avons rajouter un attribut int levelMode, ainsi que deux attribut Level, levelIntro, qui est celui dans lequel on arrive en lançant le jeu, et levelChoixNiveau, qui est celui dans lequel on peut choisir le niveau que l’on veut jouer. Le passage de niveau se fait donc par rapport au levelMode dans lequel on est. Il y en a 4 possibles :
0 : ramène au niveau d’intro. C’est celui qui sera de base au lancement du jeu
1 : c’est le mode histoire. Dans celui ci les niveaux seront pris dans le tableaux levels initialisé comme argument de  Simulator. Il contient tous les niveaux dans le bon ordre
2 : Permet d’accéder au levelChoixNiveau
3 : Le mode de jeu qui se met lorsqu’un joueur choisit un niveau depuis levelChoixNiveau. Il est configuré de manière à ramener le joueur au LevelChoixNiveau à la fin du level choisit
Tous ces changements de niveau de jeu sont fait grâce à la classe Exit, qui se trouve dans le package platform.game.Actor. (et donc quelques méthodes comme getLevelMode,changeLevelMode... se trouvent dans l’interface World, afin que Exit, qui est un Acteur, puisse les appeler. (voir World)). Nous avons donc rajouté la méthode changeLevelMode(int levelMode) permettant de changer le mode jeu puis activant le changement de niveau (en appelant nextLevel()). nextLevel() à été aussi adaptée par rapport à quel mode de jeu est actif. Le changement (donc désenregistrement des acteurs et enregistrement du niveau suivant) se fait dans la méthode update de simulator. Grâce au boolean transition, mis à true par nextLevel(), cela permet de changer le niveau (en désenregistrant les acteurs,...).
Toujours dans l’optique d’un niveau accés histoire, nous avons ajouté l’attribut boolean checkpoint ainsi que ses get/set. Celui ci est utilisé par la classe Chackpoint, se trouvant dans le package package platform.game.Actor et permet de changer la position de spawn du joueur si celui ci a déjà passé une certaine distance. Nous ne l'utilisons que dans certains niveaux, qui seraient sinon trop longs. Ces méthodes sont de nouveau mise dans World, pour les mêmes raison que pour les méthodes concernant les changement de level. checkpoint est toujours remis à false lors d’un changement de niveau.
World (interface): cette interface n’a non plus reçu aucun changement à part les méthodes ajoutées que nous avons mentionné ci-dessus (donc celles par rapport au choix de niveau, ainsi que pour le checkpoint
- Package platform.game.Actor :
Ce package contient toutes les sous classes héritant d’Actor. Nous avons laissé Actor dans le package platform.game pour éviter d’avoir des problèmes avec certaines méthodes protected dans Actor et qui étaient utilisée dans simulator.
acteurOverlay(interface) : cette interface est implémentées par les classes Player et Boss, et utilisée par la classe Overlay. Elle permet d’avoir un overlay sur d’autre classes que Player, comme prévu originellement dans le pdf. Les méthodes qui s’y trouvent servent à calculer la position d'affichage ainsi que le nombre d’HP restant,...
Checkpoint : Cette classe permet de garder en mémoire si le joueur est déjà arrivé à un certain point du niveau. Lorsque le joueur passe par le checkpoint, l’attribut checkpoint de Simulator (voir simulator) est mis à true jusqu’à ce qu’au changement de niveau. En mettant un if/else dans le niveau ayant un checkpoint, changeant la position du joueur dépendamment de si checkpoint est true ou pas, on peut ainsi créer des niveaux plus longs. Checkpoint possède aussi deux dessin, s’il est actif ou pas (ainsi que les tailles qui vont avec). 
Damage (énumération) : Regroupe tous les effets existant. Chaque effet a une valeur (un double) associée. On peut accéder à celle ci grâce à la méthode getDamage() :
Fire : utilisé pour gérer les dégâts infligés par les fireball (et sous-classe) ainsi que pour moverFire. 
Physical : utilisé pour gérer les dégâts infligés par les spikes.
Air : utilisée pour gérer les “dégâts” aériens. Ils éteignent notamments les troches, ainsi que les fireball, et permet de faire suater le Player lors du contact avec Jumper. La valeur permet de gérer la hauteur du saut de Player par Jumper
Void : utilisé par limite (et sous-classe). Les acteurs comme player ou fireball sont désenregistrés dès qu’ils subissent des dégâts Void. (La valeur est figurative car elle n’est pas vraiment utilisé, les acteurs se désenregistrant tout simplement du monde.
Activation : permet au joueur d’activer des leviers notamment. Il ne fait pas de dégâts à proprement parler (la valeur est donc figurative).
Heal : permet de soigner le player, grâce à Heart
SmallMonster : les dégâts infligés par nos slimes (et par d’autres monstres que nous aurions voulu rajouté probablement)
Exit : Les seuls changements à exit ont à voir avec la manière dont nous passons les niveaux (comme expliqué dans la partie sur Simulator). Il y a donc deux constructeurs de plus, qui permettent soit de changer de mode de Jeu, soit de mettre un niveau précis. Il y a aussi un attribut int levelMode, qui permet de choisir quelle option faire selon le constructeur utilisé. Ces choix se feront dans Intercat, où nous avons agrandit la partie se situant après que le programme aille vu que le joueur est rentré en contacte avec la box d'Exit.
Fireball : Nos boules de feu se comportent physiquement de la même manière que dans le pdf. Nous avons cependant rajouté un attribut cooldown, qui permet de donner un temps de vie aux boules de feu. Après un certain laps de temps (5 sec dans notre cas) la boule de feu se désenregistrera du monde automatiquement (afin d'éviter d'avoir des dizaines et dizaines de boules de feu rebondissant dans tous les sens). Nos boules de feu "s'éteignent" lorsqu'elle reçoivent des dégâts air, et disparaissent au contacte de Void (tout cela se trouve dans la méthode hurt). Enfin lorsqu'elles entrent en collision avec un acteur qui est réceptif au dégât FIRE, il se désenregistrera automatiquement (pour éviter que la boule de feu n'élimine l'acteur qui est hurt par FIRE en 1 seconde).
FireballBoss : cette sous classe de fireball (que nous n'avons pas mis dans un package spécifique car c'est la seul) est utilisée par notre classe Boss. Elle diffère de fireball dans le faite qu'elle n'est pas susceptible à la gravité. Elle rebondira toujours sur les acteurs solides, mais n'aura plus une trajectoire parabolique mais droite. Toute ceci a été fait dans l'idée d'apporter une capacité supérieure et différente à notre boss de celle du Player, ainsi que pour pouvoir les différenciers de celle que le Player lance. De plus cela rajoute une idée d'esquive des fireballBoss dans le dernier niveau. Elle ont cependant toujours une espérance de vie réduite. La taille des fireballBoss est plus grande que celle des fireball normales (car c'est quand même les fireball du Boss, qui est lui même bien plus grand que notre Player. Cela apporte donc un peu de cohérence aux attaques de notre Boss).
Heart : Cette classe n'a pas été changée par rapport à ce qui est proposé dans le pdf.
Jumper : jumper n'a pas été grandement changer, à part pour sa priorité, qui change dépendamment s'il est actif ou non (ceci pour résoudre un bug que nous avions avec notre Player. La priorité est donc au dessus de Player lorsque le jumper est préparé à rebondir, et en dessous lorsqu'il est en repos. Nous la baissons pour que le joueur le reconnaisse comme un acteur solide (car si la priorité est supérieure, il passerai au travers)).
Key : Cette classe n'a pas été changée par rapport à ce qui est proposé dans le pdf (A part l'ajoute d'attribut final String statics qui permettent de faciliter la construction d'une clé. Ceux ci ont la String nécessaire à adapter le sprite de la clé selon la couleur désirée (uniquement dans l'optique encore un fois de faciliter la construction)).
Lava : cette sous-classe de limits est, comme son nom l'indique, permet de modéliser de la lave. Elle hérite de limite parce que comme cette dernière elle inflige aussi des dégâts void aux acteurs avec qui elle interagit. Elle ne redéfinit donc que la méthode draw.
Lever : Cette classe ne diffère de la version proposée dans le pdf que d'un point : elle ne possède pas un cooldown la remettant à zéro après un certain temps. Nous avons décidé de ne pas implémenter cela, car pour nous les leviers ne servaient que d'outil pour obliger le joueur à traverser des obstacles. L'idée du cooldown aurait donc augmenter la difficulté des niveaux (notamment Level_07). Nous avons donc choisi de ne pas implémenter cela.
limiteTangible : Cette classe permet de modéliser une limite solide sur laquelle le joueur ne peut pas sauter. Cela est fait grâce à la méthode isLimiteTangible, retournant un boolean, qui se trouve aussi dans Actor et qui est redéfinie ici. De base un acteur n'est pas une limite tangible, ce qui fait que la méthode renvoie faux de base. Dans limiteTangible cette méthode renvoie true. Cette classe permet donc de créer des barrières invisibles et solides qui ne tuent pas le joueur au contact, ce qui est utile pour bien définir les limites du niveau.
Limits : Cette classe n'a pas été changée par rapport à ce qui est proposé dans le pdf.
Locker : cette classe est celle qui dans le pdf est appelée door. Nous avons changé son nom pour locker, car cela faisait plus de sens par rapport à l’utilisation que nous allions leur donner (en effet ils “lock” le passage). Nous avons aussi rajouté quelques composantes, notamment un cooldown. Cette classe a deux constructeurs. Le premier est celui qui est en accord avec ce qui est proposé dans le pdf. Le deuxième prend un double cooldown, qui initialisera l’attribut du même nom. Il fera que lorsque le signal passe à true, le locker attendra un certain temps avant de disparaître (ceci est très utilisé dans le Level_08). Ce constructeur prend aussi un boolean, qui permet de dire à la classe qu’il faut passer en “mode” cooldown (cela aurait été plus intelligent de ne pas prendre le boolean comme argument et de simplement mettre l’attribut à true dans le constructeur, mais au moment où j’écris ceci nous avons déjà trop utilisé ce constructeur, en modifier l'en tête serait désastreux).
Monster : cette classe abstraite sert de base à nos monstres (les slimes et le boss, voir le package platform.game.Actor.monsters. C'est pourquoi nous l'avons rendu abstraites, car même si les monstres bougent principalement de la même manière et se comportent de la même manière, ils ne subissent peut être pas les mêmes dégâts, et ne sont pas dessinés de la même façon (d'où le faite d'avoir mis les méthode hurt et draw abstract dans monster). Un monstre es caractérisé par une Box boxDAction, qui est la box dans laquelle le monstre va patrouiller. Si un joueur entre dans cette boxDAction, le monstre le détectera (voir interact). Si le player n'est pas dans la boxDAction, le monstre la patrouillera en ligne droite (les monstres ne peuvent pas sauter) le long de cette boxD'action, en faisant demi tour à chaque fois qu'il atteint le bord de la box (tout cela est calculé dans la méthode update. Le monstre sait dans quelle direction (gauche ou droite) il va grâce à un attribut boolean directionDroite (true quand il va vers la droite, false quand il va vers la gauche)) Si le player est dans la boxDAction, le monstre mettra son attribut boolean triggered à true, et gardera le Player en qeustion en mémoire frâce a un attribuut de type Player theEnnemi. Cela changera sa manière de se comporter dans update. Il se dirigera vers le Player, jusqu'à ce que celui ci sorte de la boxDAction ou que le monstre meurt. Tous les mouvements du monstre sont faits par rapport à sa position, et non par rapport à un attribut vitesse, car il nous a sembler plus facile de l'implementer ainsi. De plus nos monstres ne devaient pas être trés poussés, nous les voulions que comme obstacle aditionnel. Si nous avions eu plus de temps nous aurions peut être envisagé de repenser la façon dont les monstres bougent.
Overlay : Le but de cette classe n'a pas changé par rapport au pdf, mais nous avons élargi son champ d'action. Au lieu de ne pouvoir être que sur un Player, nous avons décidé de généraliser son concept en introduisant une interface acteurOverlay, qui permet de mettre une interface non plus qu'au Player, mais aussi à des monstres (par exemple le boss)(voir ActeurOverlay dans le package actuel). Nous avons aussi décidé de n'afficher que des coeurs pleins ou vides, et pas de demi coeur, afin de réduire et de généraliser le code.
Particle : Cette classe ne change pas de la version proposée dans le pdf, à part le fait qu’elle ne possède pas des setters pour ses attributs, ils sont tous initialisés dans le constructeur (Cela nous semblait plus simple, de plus pour l’utilisation que nous leur réservions nous n’avions pas besoin de toutes ces méthodes).

