Voici le fichier conception de notre mini-projet. Nous l’avons structuré comme ceci : Nous allons nous arrêter sur chaque package pour expliquer pourquoi nous avons créé ce package (sauf pour platform.game, celui la étant déjà existant) ainsi qu’en expliquant les détails d’implémentation des classes comme demandés dans les consignes. Les interfaces et énumérations sont indiquées.
Avant de commenecr, expliquons d’abord que les package inclus dans platform.game ont tous une volonté de faciliter la recherche d’une classe. Ils sont tous orientés autour de la même idée : Lorsqu’une classe à beaucoup de sous-classes, nous lui créons une package dédié, où nous mettons toutes les sous-classes.


Package platform.game :
Actor : Nous avons décidé de mettre la box et Sprite dans Actor, car ce sont des attribut que tous les acteurs partagent. Idem pour World et priority. Nous n’avons pas changé les méthodes fournies pour cette classe. Nous avons uniquement rajouté certains setters et getters, notamment pour sprite et box. setSprite est public à cause de notre packaging, nous ne pouvions pas la mettre en protected. Les méthodes isPlayer et isLimiteTangible permettent d’éviter les instanceOf et facilitent le code.
Simulator : De nouveau nous n’avons pas beaucoup changé les méthodes importantes du code qui ont été proposées. Nos seuls changement sont par rapport à nos changement de niveaux. Dans notre envie de créer un jeu composé d’un mode histoire et d’un mode où l’on peut choisir son niveau, nous avons rajouter un attribut int levelMode, ainsi que deux attribut Level. levelIntro, qui est celui dans lequel on arrive en lançant le jeu. Et levelChoixNiveau qui est celui dans lequel on peut choisir le niveau que l’on veut jouer. Le passage de niveau se fait donc par rapport au levelMode dans lequel on est. Il y en a 4 possibles :
0 : ramène au niveau d’intro. C’est celui qui sera de base au lancement du jeu
1 : c’est le mode histoire. Dans celui ci les niveaux seront pris dans le tableau levels initialisé comme argument de Simulator. Il contient tous les niveaux dans le bon ordre
2 : Permet d’accéder au levelChoixNiveau
3 : Le mode de jeu qui se met lorsqu’un joueur choisit un niveau depuis levelChoixNiveau. Il est configuré de manière à ramener le joueur au LevelChoixNiveau à la fin du level choisit
Tous ces changements de niveau de jeu sont fait grâce à la classe Exit, qui se trouve dans le package platform.game.Actor. (et donc quelques méthodes comme getLevelMode,changeLevelMode... se trouvent dans l’interface World, afin que Exit, qui est un Acteur, puisse les appeler. (voir World)). Nous avons donc rajouté la méthode changeLevelMode(int levelMode) permettant de changer le mode jeu puis activant le changement de niveau (en appelant nextLevel()). nextLevel() à été aussi adaptée par rapport à quel mode de jeu est actif. Le changement (donc désenregistrement des acteurs et enregistrement du niveau suivant) se fait dans la méthode update de simulator. Grâce au boolean transition, mis à true par nextLevel(), cela permet de changer le niveau (en désenregistrant les acteurs,...).
Toujours dans l’optique d’un niveau axé histoire, nous avons ajouté l’attribut boolean checkpoint ainsi que ses get/set. Celui ci est utilisé par la classe Checkpoint, se trouvant dans le package package platform.game.Actor et permet de changer la position de spawn du joueur si celui ci a déjà passé une certaine distance. Nous l’utilisons sur les niveaux longs. Ces méthodes sont de nouveau mise dans World, pour les mêmes raisons que pour les méthodes concernant les changement de level. checkpoint est toujours remis à false lors d’un changement de niveau.
World (interface): cette interface est aussi restée inchangée, sauf pour les ajouts des méthodes que nous avons mentionné ci-dessus (donc celles par rapport au choix de niveau, ainsi que pour le checkpoint)


Package platform.game.Actor :
Ce package contient toutes les sous classes héritant d’Actor. Nous avons laissé Actor dans le package platform.game pour éviter d’avoir des problèmes avec certaines méthodes protected dans Actor et qui étaient utilisée dans simulator.
acteurOverlay(interface) : cette interface est implémenté par les classes Player et Boss, et utilisée par la classe Overlay. Elle permet d’avoir un overlay sur d’autres classes que Player, comme prévu originellement dans le pdf. Les méthodes qui s’y trouvent servent à calculer la position d'affichage ainsi que le nombre d’HP restant,...
Checkpoint : Cette classe permet de garder en mémoire si le joueur est déjà arrivé à un certain point du niveau. Lorsque le joueur passe par le checkpoint, l’attribut checkpoint de Simulator (voir simulator) est mis à true jusqu’à ce qu’au changement de niveau. En mettant un if/else dans le niveau ayant un checkpoint, la position initiale du joueur change selon si checkpoint est true ou pas. On peut ainsi créer des niveaux plus longs. Checkpoint possède aussi deux dessin, s’il est actif ou pas (ainsi que les tailles qui vont avec). 
Damage (énumération) : Regroupe tous les effets existant. Chaque effet a une valeur (un double) associée. On peut accéder à celle ci grâce à la méthode getDamage() :
Fire : utilisé pour gérer les dégâts infligés par les fireball (et sous-classe) ainsi que pour moverFire. 
Physical : utilisé pour gérer les dégâts infligés par les spikes.
Air : utilisée pour gérer les “dégâts” aériens. On l’utilise pour éteindre les torches, ainsi que infliger des dégâts à Player lors du contact avec Jumper pour le faire sauter. La valeur permet de gérer la hauteur du saut de Player par Jumper
Void : utilisé par limite (et sous-classes). Les acteurs comme player ou fireball sont désenregistrés dès qu’ils subissent des dégâts Void. (La valeur est figurative car elle n’est pas vraiment utilisée, les acteurs se désenregistrent tout simplement du monde.
Activation : permet au joueur d’activer des leviers notamment. Il ne fait pas de dégâts à proprement parler (la valeur est donc figurative).
Heal : permet de soigner le player, grâce à Heart
SmallMonster : les dégâts infligés par nos slimes (et par d’autres monstres que nous aurions voulu rajouté probablement)
Exit : Les seuls changements à exit sont en lien avec la manière dont nous passons d’un niveau à l’autre (comme expliqué dans la partie sur Simulator). Il y a donc deux constructeurs de plus, qui permettent : soit de changer de mode de Jeu, soit de mettre un niveau précis. Il y a aussi un attribut int levelMode, qui permet de choisir quelle option faire selon le constructeur utilisé. Ces choix se feront dans Interact où nous avons agrandit la partie se situant après que le programme ait vu que le joueur est rentré en contacte avec la box d'Exit.
Fireball : Nos boules de feu se comportent physiquement de la même manière que dans le pdf. Nous avons cependant ajouté un attribut cooldown qui permet de donner un temps de vie aux boules de feu. Après un certain laps de temps (5 sec dans notre cas) la boule de feu se désenregistrera du monde automatiquement (afin d'éviter d'avoir des dizaines et dizaines de boules de feu rebondissant dans tous les sens). Nos boules de feu disparaissent au contacte de Void (tout cela se trouve dans la méthode hurt). Enfin lorsqu'elles entrent en collision avec un acteur qui est réceptif au dégât FIRE, elle se désenregistrera automatiquement (pour éviter que la boule de feu n'élimine l'acteur qui est hurt par FIRE en 1 seconde).
FireballBoss : cette sous classe de fireball (que nous n'avons pas mis dans un package spécifique car c'est la seul) est utilisée par notre classe Boss. Elle diffère de fireball dans le faite qu'elle n'est pas susceptible à la gravité. Elle rebondira toujours sur les acteurs solides, mais n'aura plus une trajectoire parabolique mais droite. Toute ceci a été fait dans l'idée d'apporter une capacité supérieure et différente à notre boss de celle du Player. Aussi pour pouvoir les différencier de celle que le Player lance. De plus cela permet au joueur d'esquiver les fireballBoss dans le dernier niveau. Elle ont cependant toujours une espérance de vie réduite. La taille des fireballBoss est plus grande que celle des fireball normales (car c'est quand même les fireball du Boss, qui est lui même bien plus grand que notre Player. Cela apporte donc un peu de cohérence aux attaques de notre Boss).
Heart : Cette classe n'a pas été changée par rapport à ce qui est proposé dans le pdf.
Jumper : jumper n'a pas été grandement changé, à part pour sa priorité. Elle change dépendamment s'il est actif ou non (ceci pour résoudre un bug que nous avions avec notre Player. La priorité est donc au dessus de Player lorsque le jumper est préparé à rebondir, et en dessous lorsqu'il est en repos. Nous la baissons pour que le joueur le reconnaisse comme un acteur solide (car si la priorité est supérieure, il passerai au travers)).
Key : Cette classe n'a pas été changée par rapport à ce qui est proposé dans le pdf (A part l'ajout d'attribut final String statics qui permettent de faciliter la construction d'une clé. Ceux ci ont la String nécessaire à adapter le sprite de la clé selon la couleur désirée (uniquement dans l'optique encore un fois de faciliter la construction)).
Lava : cette sous-classe de limits, comme son nom l'indique, permet de modéliser de la lave. Elle hérite de limite parce que comme cette dernière elle inflige des dégâts void aux acteurs avec qui elle interagit. Elle ne redéfinit donc que la méthode draw.
Lever : Cette classe ne diffère de la version proposée dans le pdf que d'un point : elle ne possède pas un cooldown la remettant à zéro après un certain temps. Nous avons décidé de ne pas implémenter cela, car pour nous les leviers ne servaient que d'outil pour obliger le joueur à traverser des obstacles. L'idée du cooldown aurait donc augmenter la difficulté des niveaux (notamment Level_07). Nous avons donc choisi de ne pas implémenter cela.
limiteTangible : Cette classe permet de modéliser une limite solide sur laquelle le joueur ne peut pas sauter. Cela est fait grâce à la méthode isLimiteTangible, retournant un boolean, qui se trouve aussi dans Actor et qui est redéfinie ici. De base un acteur n'est pas une limite tangible, ce qui fait que la méthode renvoie faux de base. Dans limiteTangible cette méthode renvoie true. Cette classe permet donc de créer des barrières invisibles et solides qui ne tuent pas le joueur au contact, ce qui est utile pour bien définir les limites du niveau.
Limits : Cette classe n'a pas été changée par rapport à ce qui est proposé dans le pdf.
Locker : cette classe est celle qui dans le pdf est appelée door. Nous avons changé son nom pour locker, car cela faisait plus de sens par rapport à l’utilisation que nous allions leur donner (en effet ils “lock” le passage). Nous avons aussi rajouté quelques composantes, notamment un cooldown. Cette classe a deux constructeurs. Le premier est celui qui est en accord avec ce qui est proposé dans le pdf. Le deuxième prend un double cooldown, qui initialisera l’attribut du même nom. Lorsque ce signal passe à true, le locker attendra un certain temps avant de disparaître (ceci est très utilisé dans le Level_08). Ce constructeur prend aussi un boolean, qui permet de dire à la classe qu’il faut passer en “mode” cooldown (cela aurait été plus intelligent de ne pas prendre le boolean comme argument et de simplement mettre l’attribut à true dans le constructeur, mais au moment où j’écris ceci nous avons déjà trop utilisé ce constructeur, en modifier l'en tête serait désastreux).
Monster : cette classe abstraite sert de base à nos monstres (les slimes et le boss, voir le package platform.game.Actor.monsters. C'est pourquoi nous l'avons rendu abstraite. Même si les monstres bougent principalement de la même manière et se comportent de la même manière, ils ne subissent peut être pas les mêmes dégâts, et ne sont pas dessinés de la même façon (d'où le faite d'avoir mis les méthode hurt et draw abstract dans monster). Un monstre est caractérisé par une Box boxDAction, qui est la box dans laquelle le monstre va patrouiller. Si un joueur entre dans cette boxDAction, le monstre le détectera (voir interact). Si le player n'est pas dans la boxDAction, le monstre la patrouillera en ligne droite (les monstres ne peuvent pas sauter) le long de cette boxD'action, en faisant demi tour à chaque fois qu'il atteint le bord de la box (tout cela est calculé dans la méthode update. Le monstre sait dans quelle direction (gauche ou droite) il va grâce à un attribut boolean directionDroite (true quand il va vers la droite, false quand il va vers la gauche)). Si le player est dans la boxDAction, le monstre mettra son attribut boolean triggered à true, et gardera le Player en mémoire grâce à un attribut de type Player theEnnemi. Cela changera sa manière de se comporter dans update. Il se dirigera vers le Player, jusqu'à ce que celui ci sorte de la boxDAction ou que le monstre meurt. Tous les mouvements du monstre sont faits par rapport à sa position, et non par rapport à un attribut vitesse, car il nous a semblé plus facile de l'implémenter ainsi. De plus nous ne voulions pas que nos monstres soient très complexes mais qu’il agissent simplement comme un obstacle additionnel. Si nous avions eu plus de temps nous aurions peut être envisagé de repenser la façon dont les monstres bougent.
Overlay : Le but de cette classe n'a pas changé par rapport au pdf, mais nous avons élargi son champ d'action. Au lieu de ne pouvoir être que sur un Player, nous avons décidé de généraliser son concept en introduisant une interface acteurOverlay, qui permet aussi de mettre une interface à des monstres (par exemple le boss)(voir ActeurOverlay dans le package actuel). Nous avons aussi décidé de n'afficher que des coeurs pleins ou vides, et pas de demi coeur, afin de réduire et de généraliser le code.
Particle : Cette classe ne change pas de la version proposée dans le pdf, à part le fait qu’elle ne possède pas des setters pour ses attributs. Ils sont tous initialisés dans le constructeur (Cela nous semblait plus simple. De plus, pour l’utilisation que nous leur réservions, nous n’en avions pas besoin de toutes ces méthodes).
Player : Notre joueur est fondamentalement le même que dans le pdf. Nous avons cependant changé quelques touches permettant de bouger,... (selon ce qui nous semblait cohérent(voir README)). Nous avons aussi ajouté un cooldown au lancé de boule de feu, pour éviter que le Player soit trop puissant face à nos monstres (il ne peut lancer que 2 fireballs avant de rentrer en cooldown). Nous avons aussi ajouté un attribut String lastKey qui nous permet de savoir dans quelle direction (gauche ou droite) va le joueur, ce qui nous permet de savoir dans quelle direction lancer la boule de feu. Nous utilisons le même système pour les dégâts Air qu’inflige Player. 
Nous avons donné la capacité au Player de pouvoir faire des sauts muraux. Pour cela, Player doit être en contact avec un mur. Il existe deux type de sauts muraux: le saut mural en longueur, et le saut mural en hauteur. Pour le premier, le Player doit appuyer sur la touche directionnelle droite/gauche et sur la touche espace, tout en étant en contact d’un mur, pour faire un saut mural en longueur. Le deuxième saut mural s’exécute comme avant, sauf qu’il faut en plus appuyer sur la touche directionnelle haut. Nous avons laissé la possibilité au joueur de choisir entre ces deux type de sauts muraux. Les deux diffèrent du fait que le saut en hauteur va surtout servir à grimper, tandis que l’autre va servir à descendre ou à faire des sauts horizontaux. La difficulté de notre saut mural réside dans le fait qu’il faut appuyer sur la flèche directionnelle inverse à la direction où le joueur veut sauter. Ce choix s’est fait car Player ne restant pas collé au mur, il se décollait de celui-ci aussitôt que le joueur orientait son saut mural dans la direction voulue.
Nous redéfinissons la méthode isPlayer présentée dans la section de la classe Actor. Enfin, l’attribut boolean limite est la pour savoir si le joueur est en contacte avec une limite tangible (pour après empêcher les sauts dans update).
Scie : une scie est un acteur infligeant des dégâts VOID (comme dans la réalité). Sa priorité est juste assez pour que le joueur meurt au contacte et pour que le fireball rebondisse dessus (car la scie ne fait pas de dégâts à Fireball). Les scies se trouvent surtout au Level_08
SignalAlternant : Cette classe est un acteur implémentant signal. Sa particularité est que tout les x sec le signal qu’elle renvoie à travers isActive change. Le temps est pris comme paramètre dans le constructeur. C’est donc un acteur invisible et qui n’a pas de corps.
SignalInvisibleConstant : Cette classe est un acteur implémentant signal et caractérisé par sa box. Lorsque le joueur rentre en collision avec celle ci, le signal renvoyé par la classe passe à true et ne change plus. Nous l’utilisons pour activer des pièges lorsque le joueur atteint un point précis
SignalInvisibleCollision : Cette classe ressemble à SignalInvisibleConstant, à la seule différence que le signal est true que quand le joueur est dans la box. Nous l’avons créé pour pouvoir display du texte dans certains niveaux pendant que le joueur avance.
SignalReadKey : Cette classe est un acteur implémentant signal. Lorsque l’on appuie sur une touche prédéfinie (B en l'occurrence), son signal va passer à true, puis redevenir false. Nous l’avons créer pour avoir un moyen de faire display plusieurs texte sans avoir besoin d’un Player. (voir Level_00)
Spikes : Cette classe n’a pas été changée par rapport au pdf, à part pour le fait que le Player subit des dégâts au contact avec le spikes, et non pas si sa vitesse est non nul. Nous avons décidé de faire cela car pour nous le Player, même s’il est immobile au dessus des spikes, devait quand même prendre des dégâts. Cela nous semblait logique et prenait sens par rapport à ce qu’on voulait en faire dans nos niveaux.
Nos spikes ont une taille prédéfinie, on ne peut choisir que la position. Nous faisons cela car comme nous n’avons qu’un seul sprite pour nos spikes, la taille aurait de toute façon été la même. Cette méthode facilite donc le constructeur 
SpikesDroite, SpikesGauche, SpikesBas : Ces sous classes de spikes n’ont de différents que l’orientation et le sprite. Comme leur nom l'indique, elles sont orientées dans un sens prédéfinis. Ces sous classes suivent notre idée d’avoir des spikes dont on ne peut pas changer la taille.
Teleporteur : Cette classe permet, lorsque le player rentre en collision avec sa box, de téléporter ce dernier vers une position prédéfinie. Ceci est fait au moyen de la méthode setPosition dans Player. Elle a 4 sprites, qui vont être dessinés en alternance. Cette classe ajoute un nouvel élément à notre jeu.
Torch : Cette classe n'a pas été changée par rapport à ce qui est proposé dans le pdf.


package platform.game.Actors.blocks
Ce package regroupe toutes les sous classes de block, qui étaient très nombreuse.
Block, Mover : Ces classes n'ont pas été changée par rapport à ce qui est proposé dans le pdf.
BlockDeco : Nous utilisons cette classe pour modéliser tous les backgrounds. Elle hérite de Block mais diffère uniquement par le fait qu’elle n’est pas solide et par le fait que sa priorité est plus basse, pour être dessinée en arrière plan.
BlockDecoSignal : cette sous-classe de BlockDeco ne se dessine que si elle reçoit un signal. Nous l’utilisons pour dessiner nos textes notamment.
BlockDecoTexte : Cette sous-classe de BlockDeco possède une liste de BlockDeco. En utilisant un signalReadKey (voir ci-dessus) elle va les display l’un après l’autre, de la manière suivant : cette classe va s’approprier de la box et du sprite du BlockDeco à dessiner et le garder jusqu’à ce qu'elle reçoive un signal. Elle va alors faire la même chose avec le blockDeco suivant, et ainsi de suite jusqu’au dernier Block. Lorsqu'elle recevra un signal, elle se désenregistrera du monde et changera de niveau si voulu. Il faut pour cela initialiser une composante boolean aloneInWorld à true lors de la construction.
Cette classe a été désignée spécifiquement pour notre niveau prologue (voir Level_00). Elle permet d’avoir un moyen simple de passer entre plusieurs sprites de texte dans un niveau ou il n’y a pas de Player. Elle aurait parfaitement pu être aussi utilisée dans un éventuel niveau épilogue.
BlockDisparitionSignal : Cette sous-classe de Block a comme attribut un signal. Celui ci permet de savoir si le block doit apparaître ou pas, dépendamment du signal renvoyé. Lorsque le bloque n'apparaît pas, sa box est set à nul. Ce bloc permet d'ajouter un nouveau niveau de difficulté dans nos niveaux (voir Level_05).
BlockIndecis : cette sous-classe de Block est caractérisée par deux timer. Il apparait et disparait selon ceux-ci. Lorsqu’il apparaît il a un sprite normal. Lorsqu’il disparaît il cesse d’être solide et son sprite change aussi. Cette classe permet de rajouter une composante de timer, car le joueur doit soit avoir beaucoup de chance soit connaître plus ou moins les timer. Or on ne peut les connaître que si on a programmé le jeu ou si l’on est mort plein de fois, ce qui est ce que nous voulions lorsque nous avons conçu le jeu.
MoverDamageFire : Cette sous-classe de mover inflige comme son nom l'indique des dégâts de feu. Ce sont donc en quelque sortes des boules de feu, mais dont le mouvement est prédéfini. Nous avons donc juste rajouté un appel au hurt de other dans la méthode interact, et nous leur avons donné un cooldown, pour éviter qu’ils n’éliminent le Player en un contact. Les moverDamageFire ne sont pas solides, pour que le joueur ne se fasse pas pousser par les boules de feu.
MoverDamageLava : Cette-sous classe de mover inflige des dégâts VOID au joueur qu’elle rencontre. Elle le fait de la même manière que la classe Lava, présenté ci dessus. Sa particularité est qu’elle a deux box, une pour le dessin et une qui est sa hitBox. Nous avons implémenté cela car, à cause de nos sprites, le joueur était tué avant qu’il ne touche vraiment la lave. Nous avons donc réduit sa hitbox.


package platform.game.levels
Ce package était déjà existant, nous nous sommes contenté d’y ajouter des Classes pour chacun de nos niveau. Celles ci ont exactement la même méthode que dans basicLevel, et nous n’avons pas touché à la classe Level


package platform.game.Actors.monsters
Ce package contient les classes héritant de monster.
Slime : cette sous-classe de monster est celle qui représente le plus le monstre de base que nous avions en tête lors de la création de monster. Nous avons pensé le slime comme une entité qui, à sa mort, peut faire apparaître deux petites version d’elle même. Elle possède pour cela deux attributs boolean, bigBrotherIsDead et showMustGoOn. Le premier sert à avertir la classe que le slime est mort, la deuxième est initialisée au constructeur et permet de savoir si le slime doit faire spawn de plus petit slimes à la mort. 
Les slimes infligent un des dégâts SMALLMONSTER, et sont sensibles au dégâts FIRE et VOID. Leur dessin est particulier. En effet dépendant dans quelle direction se dirige le slime son dessin va changer. Nous utilisons pour savoir cela l’attribut DirectionDroite présent dans monster. De plus nous avons 3 sprites pour chaque direction, qui alternent. Or ces sprites n’ont pas tous la même taille, donc nous réduisons la hitBox à chaque changement de sprite. Le changement de sprite et de hitbox se fait grâce à un double cooldownDessin.
Boss : cette sous-classe de monster est assez particulière. En effet nous avons décidé de faire un boss statique, nous avons donc enlevé la partie qui gérait les mouvements en overridant la méthode update. Notre boss se déplace cependant entre deux position au cours de ses phases, qui sont structurées comme ceci :
Avant que le joueur n’arrive dans la salle, le boss se trouve dans sa positionRepos, qui n’est pas accessible par le joueur. Dès que le joueur atteint la salle le boss se déplace à sa positionCombat et le combat commence. Le boss, lorsqu’il se trouve en position combat, lance des fireballlBoss (voir ci-dessus). Sa première phase ne comporte rien d’autre. Lorsqu’il arrive au ? de sa vie, il se téléporte à sa position de repos, et la première interphase commence. Le boss va faire apparaître des slimes. Tant que ceux-ci ne sont pas morts, il ne repassera pas en position de Combat. Dès que les slimes sont morts, la deuxième phase commence. A partir de la deuxième phase, le boss va, toutes les x secondes, “éteindre” une boule de feu, laissant une animation permettant de le remarquer. Tout ceci est fait à l’aide d’un cooldown et de la méthode hurt. Lorsque le boss passe aux ? des ses HP, il se téléporte en positionRepos et la deuxième interphase commence. Lors de la deuxième interphase, un moverLava va monter et disparaître après un certain temps. Le joueur va devoir grimper au mur à gauche pour éviter la lave. Un coeur va aussi apparaître au milieu de la plateforme. Lorsque la lave disparaît, la phase 3 commence. Lors de la phase 3, le boss ne va rien faire de nouveau. Lorsque le boss n’a plus d’HP, il va disparaître et faire disparaître un mur derrière lui, révélant la sortie. 
Le boss subit des dégâts FIRE. Son sprite est différent selon s’il est en positionCombat ou s’il est en positionRepos. La majeur partie des attributs qui ne sont pas constants dans notre boss ont été donné en paramètre dans le constructeur. Le boss implémente ActeurOverlay, ce qui lui permet d’avoir un Overlay. 
package platform.game.Signal
Ce package contient toutes les classes implémentant Signal, et qui n'héritent pas d’actor. Cela comprend donc Signal, And, Or, Not, Constant. Nous n’avons pas modifié ces classes par rapport à ce qui est proposé dans le pdf.
